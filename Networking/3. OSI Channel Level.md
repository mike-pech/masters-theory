Казалось бы — приняли сигнал на физическом уровне, пусть и с его ограничениями и особенностями — зачем ещё один уровень?

> [!INFO] Каждый новый уровень OSI даёт новый набор интерфейсов и абстракций

Физический уровень даёт лишь возможность передачи сигнала.

Следующий уровень — канальный — даёт возможность проверять и отлавливать ошибки приёма сигнала. Если пользователей много, то приёмник может не справляться с нагрузкой и пропускать байты в сети.

Канальный уровень работает с фреймами (кадрами) — условными группами передаваемых байтов.
## Как делить байты на фреймы?

Фрейм это:
- Заголовок (Header)
- Груз (Payload)
- Конец (Trailer)

![[Pasted image 20250920115942.png]]
#### Наивный подход — подсчёт байтов
Просто считываем количество байтов в заголовке фрейма и считаем это количество полученных байтов

Не работает, если заголовок считан неправильно или не считан совсем
#### Байт-стаффинг
«Впихиваем» все байты пакета между разделителями — служебными байтами с возможностью экранирования подобно `\`
#### Битовый флаг с байт-стаффингом
Аналогично байт-стаффингу ставим служебные биты, обозначающие конец фрейма — более компактный метод

> [!INFO] Зачастую применяется несколько разных способов обработки фреймов
## Обработка ошибок

![[Pasted image 20250920122245.png]]

Простой метод: использовать таймер (дедлайн) пересылки пакетов — пакет недосланный до времени отбрасывается как некорректный.

![[Pasted image 20250920090732.png]]

![[Pasted image 20250920091034.png]]
Более формализованное [условие Фано](https://ru.wikipedia.org/wiki/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5_%D0%A4%D0%B0%D0%BD%D0%BE#:~:text=%D0%9E%D0%B1%D1%8B%D1%87%D0%BD%D0%B0%D1%8F%20%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D1%8D%D1%82%D0%BE%D0%B3%D0%BE%20%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F%20%D0%B2%D1%8B%D0%B3%D0%BB%D1%8F%D0%B4%D0%B8%D1%82,ab%20%D0%B2%20%D0%BA%D0%BE%D0%B4%D0%B5%20%D0%BD%D0%B5%20%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D0%B5%D1%82.). В кодировании 4B/5B (и далее в кодировании 8B/10B) все коды, ранее не согласованные между двумя сторонами считаются ошибочными, так как их не мог модулировать передатчик имеющий строго определённую таблицу модуляции — значит, это ошибка в передаче битов.

![[Pasted image 20250920091212.png]]

Альтернативный метод — корректировка ошибок вместо отбрасывания

![[Pasted image 20250920091337.png]]
![[Pasted image 20250920091342.png]]

![[Pasted image 20250920091537.png]]

![[Pasted image 20250920092809.png]]

## коммутатор (switch)

![[Pasted image 20250927100450.png]]

Служит для прямого соединения кабелей в сеть и передачи пакетов на физическом уровне во фреймах. Часто работает на 2-м уровне OSI с MAC-адресами

> MAC (media access control) адрес — физический адрес устройства 

Коммутатор помогает заглушить шум в сети и объединить релевантные кабели в соединения

Логика коммутатора очень проста:
- Перессылка пакетов по таблице коммутации
- Если пакет не имеет адреса назначения, то пересылает всем адресам — кому-нибудь придёт
### как соединить датацентры коммутаторами?

![[Pasted image 20250927101535.png]]
и при этом сделать отказоустойчиво?

С такой топологией есть проблема — петля. коммутатор тупой и будет постоянно пересылать пакеты по кругу без никакого конца и края — коммутатор рассчитан на древовидную структуру
### STP — spanning tree protocol

Протокол, который служит для создания дерева из петли путём убирания линков сети, и создания тем самым ацикличного графа и тем самым дерева

Протокол умный — если какой-то линк упадёт — коммутаторы децентрализованно перестроятся на новое дерево
#### Как это сделать?

Нужно:
- Сделать децентрализованную структуру
- Предусмотреть запасного лидера на роль корня дерева
- Передавать друг другу информацию чеерз BPDU (ID отправителя, получателя, cost и т.д.)

Фишка STP — выбор наиболее дешёвого маршрута для передачи конкретного пакета

Тем самым мы получаем децентрализованный протокол передачи данных по ацикличной сети
#### portfast 
Особый проприетарная настройка Cisco, позволяющий сразу же перейти к работе протокола STP, вместо 15 секунд слушания. Использовать только для сети конечных пользователей, т.к. настройка делает протокол неаккуратным и может вызывать петли.
