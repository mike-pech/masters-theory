Микросервисы — зарекомендоавашая себя модель проектирования программной архитектуры, где учитывается устойчивость системы к падениям
# Контекст — монолит

Монолит для большого количества проектов это норм! Просто. Быстро. Надёжно-

...хотя не совсем надёжно. Если сломается из-за малейшей ошибки, то падает всё

Зато атомарно — ACID, а также релиз атомарный — всё что угодно будет проходить по паттерну согласованности "либо всё, либо ничего"

...но этот паттерн сложно поддерживать со временем — по мере масштабирования монолит сталкивается с разными проблемами:
- Одна ошибка кладёт весь сервис
- Монолит сложно совместно разрабатывать — merge conflict hell!
- Нет гранулярности масштабирования 
# Микросервисы

При переходе на микросервисы мы декомпозируем наш сервис 

![[Pasted image 20251118082935.png]]

- Процессы — маленькие сервисы
- Технологически агностический — разный стек под разные решения
- Легковесная коммуникация — REST API/gRPC/MQ
- Независимое масштабирование — основной плюс микросервисов
## Когда нужны микросервисы

- Команда разрастается до 15+ инженеров
- Некоторые ресурсы требуют в три раза больше ресурсов
- На деплой тратится 4+ часов
## Примеры

![[Pasted image 20251118083338.png]]

![[Pasted image 20251118083420.png]]
# Миграция — паттерн strangler fig
(паттерн фикуса-душнилы)

- Начать с наименее значительной для пользователей функциональности, имеющей чёткие границы (аудит, сервис email)
	- Включить проксирование запросов — сначала проксируем всё монолиту
	- Параллельно разрабатываем микросервис для выбранной функциональсти
		- Переключаем трафик на соответствующем эндпоинте от монолита к новому микросервису
		- Душим — постепенно вытесняем функциональность монолита, повторяя процесс

> При переходе мы синхронизируем данные между текущим монолитом и микросервисами на которые мы переходим путём **двойной записи**
## Проксирование

При таком переходе вся архитектура представляет собой динамичный ландшафт из монолитных деплоев и канареечной среды микросервисов 

Здесь нужен чёткий контроль над запросами и нельзя выставлять случайные эндпоинты наружу. Нам нужен
### API-шлюз (API Gateway)

В микросервисной архтектуре API-шлюз выполняет роль обратного прокси, который перенаправляет все запросы в зависимости от их назначения согласно своей спецификации

Перенаправление идёт по

- Эндпоинту — направляет в соответствующий сервис
- Протоколу — при переходе API шлюз может переводить протокол запроса из внешнего HTTPS во внутренний HTTP (терминация шифрования для снижения нагрузки на сами сервисы внутри защищённой сети), gRPC/Protobuf (для быстрой коммуникации с соответствующими эндпоинтами)
- Прочие фичи — валидация запроса, CORS, логгирование для аналитики — т.к. шлюз это централизованный элемент, через который проходят ВСЕ запросы в системе

API-шлюз является частью паттерна BFF — Backend for Frontend — который разделяет шлюзы для запросов в зависимости от их платформы и соответствующей функциональности — мобильный клиент требует минимального кол-ва запросов для экономии трафика, в то время как десктопному клиенту нужны картинки в высоком разрешениии
## Исследование топологии

В масштабе микросервисной архитектуры, где сервисы поднимаются и падают каждую секунду, нужно понимать куда обращаться, ведь статические IP не применимы к такому динамическому паттерну

![[Pasted image 20251118084237.png]]

При этом важно проверять "здоровье" сервисов — зомби-серивсы, работающие, но неспособные обрабатывать запросы

Для этого вводятся т.н. Health Checks 

```nginx.conf
{
  "service": {
    "name": "redis",
    "port": 8000,
    "checks": [{
	  "http": "http://localhost:8000/health",
	  "interval": "10s"
    }]
  }
}
```
Каждые 10 секунд обращаться к сервису Redis, чтобы провести простой запрос и проверить, проходит ли он — если нет, то сервис списывается с топологии
## Коммуникация
### REST vs gRPC

Основные два подхода к коммуникации — это REST API и gRPC

| Характеристика      | REST (JSON/HTTPv1.1)                   | gRPC (Protobuf/HTTP2)                                    |
| ------------------- | -------------------------------------- | -------------------------------------------------------- |
| Формат              | Человеко-читаемый                      | Бинарный, компактный, нечитаемый                         |
| Производительность  | JSON нужно сериализовать — это оверхэд | Быстрее за счёт передачи более компактных данных         |
| Типизация           | Схема свободная                        | Строгая типизация                                        |
| Мультиплексирование | Простые, но блокирующие запросы        | Параллельные запросы через одно TCP-соединение           |
| Лучше всего для     | Публичных API, отладки                 | Внутренней быстрой межсервисной (East-West) коммуникации |
### Асинхронная обработка

Применяется также асинхронный паттерн, когда в коммуникации требуются неблокирующие операции (постановка в очередь для отправки данных для аналитики или отправки уведомления по электронной почте) 

При этом основными целями ставят прежде всего избегание блокировки от тяжёлых или времязатратных операций и амортизацию пиков нагрузки (например постановка заказов в корзину в чёрную пятницу)

Подробнее про асинхронную обработку здесь: [[Data pipelines]]
## Fail Fast

Иногда для обеспечения бесперебойной работы системы и во избежание проблем с согласованностью нужно специально убить заведомо провальные запросы
### Паттерн Circuit breaker (рубильник)

3 состояния:
- Открыт (провал) — сразу валит все запросы, потому что наступил таймаут запроса
- Закрыт (норма) — Запросы идут, ошибки считаются в пределах передвигающегося окна (за промежуток времени) — если накапливаются ошибки, то переключаем рубильник
- Приоткрыт (тестирование) — после таймаута впускаем несколько пробных запросов на проверку

Такой паттерн даёт перегруженным сервисам время встать на ноги, а упавшим сервисам плавно войти в работу
### Паттерн Bulkhead

Зарезервировать соединения в разных пропорциях для чёткой сегментации по скорости и тяжести их выполнения

К примеру:
- 30 запросов — защищённые от перегрузок запросы — поиск
- 50 запросов — быстрые запросы — авторизация действий
- 20 запросов — тяжёлые запросы — подгрузка картинок
# Согласованность данных

Для обеспечения согласованности данных уже не получится прятаться за ACID — нужен другой паттерн
## SAGA-паттерн
### Хореография 

На основе событий сервисы обрабатывают запрос один за другим — каждый выполняет свою роль, дожидаясь команды от соответствующих сервисов

Например, при обработке запроса на добавление товара в корзину:
1. Сервис каталога получает запрос на добавление товара в корзину от клиента, направляет запрос сервису склада
2. Сервис склада получает запрос и резервирует товар — в случае успеха направляет запрос сервису корзины
3. Сервис корзины получает запрос и фиксирует товар в корзине — ждёт статус оплаты от соответствующего сервиса

Если заказ отменяется, то сервисы проходят тот же путь задом наперёд

Это обеспечивает минимальную связность сервисов (что хорошо, если операции между ними самые разные и/или независимые), но усложняет трассировку запросов, за этим к микросервисам нужно подключить Jaeger
### Оркестрация

Один сервис оркестрации следит за обработкой запроса разными сервисами — отдаёт команды этим сервисам

Например, при обработке запроса на добавление товара в корзину:
1. Оркестратор отправляет команду сервису склада о том, чтобы тот зарезервировал товар
2. Оркестратор говорит сервису корзины добавить товар
3. Оркестратор спрашивает сервис оплаты о статусе оплаты

Если заказ отменяется, то нужна одна **идемпотентная** контр-транзакция 
- Оркестратор просит сервис корзины удалить товар из корзиины И сервис склада удалить бронь товара за клиентом

Это обеспечивает централизованную обработку с минимлаьным оверхэдом коммуникации, но становится узким местом при масштабировании
# Итоги перехода

Переход на микросервисы — это обмен сложности масштабирования в сложность проектирования
# Принцип работы на примере e-commerce

![[Pasted image 20251118095431.png]]

![[Pasted image 20251118095440.png]]