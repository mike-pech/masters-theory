База данных — это тот элемент, который зачастую становится узким местом для архитектуры ПО

> Примем БД за узкое место
> Запросы попадают на распределённую архитектуру в кластере контейнеров с балансировщиком нагрузки, но идут на ту же базу данных — это и единая точка отказа, и узкое место, которое замедляет производительность системы в целом

Но что если разделить нагрузку?
# SQL vs NoSQL

### SQL

Классический подход, приоритизирующий ACID, работающий на строгих определённых схемах отношений и JOIN'ах
#### Гарантии SQL

- Atomicity — транзакция это одно действие, которое либо проходит полностью, либо не проходит вообще
- Consistency — результаты транзакции предсказуемы при одних и тех же условиях
- Isolation — изоляция транзакций
- Durability — при успешной транзакции данные остаются на базе даже после сбоя в системе
### NoSQL (Not only SQL) 
> Ненавижу названия в айти...

Нереляционные базы данных жертвуют некоторыми грантиями из ACID, в угоду гибкости и BASE 
#### BASE

- Basically Available — приоритет доступности базы данных
- Soft-state — не факт, что одна и та же транзакция приведёт к тому же результату
- Eventually Consistent — мы гарантируем, что рано или поздно данные придут к консистентному состоянию
#### Примеры

- Ключ-значение — (Reids, Memcached) или JSON-документориентированные (MongoDB, CouchDB)
- Wide-column — оптимизированные для хранения больших наборов данных — в основном для аналитики (Clickhouse, Cassandra)
- Графовые БД — наиболее подходят для хранения данных о связях (рекомендательные системы) и данные для ИИ-моделей
# Ускорение чтения в Read-heavy приложениях

### Индексы 

Как индекс или оглавление в книге, помогает сразу найти нужную запись

Замедляет запись, но сильно ускорят чтение. Иногда можно оптимизировать путём использования частичных индексов (с условием). В общем случае индексировать часто запрашиваемые (SELECT) столбцы с условиями сортировки (ORDER BY) или 
### Репликация

Чтобы распределить нагрузку на чтение также можно прибегнуть к репликации — создать несколько копий БД 
#### Master-slave (Primary replica)

Несколько копирующих друг-друга серверов, из которых один — master — принимает запросы на запись и раздаёт информацию об изменениях своим fucking slaves

Очень хорошо ускорят чтение, делает систему более доступной; есть небольшой оверхед на распределение запросов и репликацию с master'а — есть задержка репликации

> [!INFO] Компромисс
> Работа с репликами синхронно — если требуется жёсткая консистентность — master ждёт конца репликации (и ждёт, и ждёт, и ждёт) и только после полной записи отправляет OK клиенту
> 
> Работа асинхронно — сразу отдать приказ и OK клиенту, нежели ждать сигнала от всех клиентов
> 
> Полу-синхронная — master ждёт OK от хотя бы n реплик (n чаще всего равен 1), но не ждёт всех реплик
# Ускорение записи

## Конфликт на запись

Если наша БД распределена и берёт много запросов на запись, то с ней могут возникнуть конфликты записи, тут нужны меры
## Шардирование

Разделение всей БД на несколько составных частей — шардов — одна большая таблица из кучи сегментов на распределённых серверах

> Как распределить нагрузку? 

Использовать Shard Key — вроде первичного ключа таблицы, но для шардов
- Range-based — разделить нагрузку по всем БД равномерно — тем не менее, распределение может оказаться неравномерным
- Hash-based — разделить по хэшам — более равномерное распределение данных, но запросы уже нельзя сделать по диапозону — тогда придётся агрегировать результаты с разных шардов
- Directory-based — сервис-каталог, который хранит карту — гибко, но оверхэд на этот сервис

Если неудачно выбрать ключи, то возникает «горячая точка» — нагрузка будет возникать на одних шардах выше, чем на других — нужно распределить нагрузку!

По шардам крайне неэффективно или вообще не возможно делать JOIN-ы

Нужно заранее продумать, по каким ключам мы будем индексировать шарды — если индекса нет, нужно опросить все шарды

![[Pasted image 20251007085541.png]]
![[Pasted image 20251007085840.png]]
![[Pasted image 20251007090634.png]]
![[Pasted image 20251007090852.png]]