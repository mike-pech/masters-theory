С ростом количества пользователей и запросов система непременно встречается с узкими местами в плане производительности. Обрабатывать растущее количество пользователей становится сложнее, задержки увеличиваются, сервера отказывают при перегрузке. При этом большинство запросов требуют одних и тех же данных. Такой расклад можно значительно оптимизировать путём:
- Кэширования (т.е. откладывания часто запрашиваемых данных)
- Балансировки нагрузки (между серверами)
#### Проблемы без правильного масштабирования:
- Одна точка отказа
- Деградация производительности
- Перегрузка базы данных
# Балансировка нагрузки

Реализуется чаще всего как шлюз при входе во внутреннюю сеть сервиса, который определяет, на какой сервер посылать пакеты
### Свойства, превносимые балансировщиками

- избегание перегрузки
- устойчивость к сбоям
## 2 реализации балансирощиков

- L4 — быстрый вариант просто на основе портов и адресов пакета — подходит для балансировки по железу
- L7 — маршрутизация запросов на основе их контента. Более гибкий функционал (например возможность расшифровывать пакеты https) — но выше задержка — подходит для логической маршрутизации (`/api` к основному приложению; `/images` к серверу с картинками)
## Алгоритмы балансировки

- Round robin — по очереди распределяем по серверам. просто, тупо, но работает во многих незамысловатых случаях. Тем не менее, не подойдёт в случае с продолжительными сессиями
- Least connections — распредляем по серверам от наименее загруженного к наиболее загруженному — есть оверхэд, так как нужно хранить количество соединений, однако позволяет учесть продолжительные сессии типа websockets
- Source ip hash — вычисляется кэш на основе ip исходного запроса (клиента) — кэш используется как идентификатор сервера — гарантирует, что возвращающийся клиент попадёт на тот же сервер (пока не изменится пул серверов)
	- Узкое место: клиенты через nat будут попадать на один и тот же сервер (т.к. их хэш будет один и тот же)
	- Узкое место (алгоритма): неравномерное распределение хэшей
### Липкие сессии

При необходимости хранить сессии клиента (например корзину в озоне при заходе с разных устройств), такие непостоянные данные скорее всего будут храниться непосредственно на сервере или в кэше (об этом ниже), поэтому можно прибегнуть к разным реализациям так или иначе связанным с балансировкой нагрузки:
- на основе данных в пакетах и l7-балансировщике
- на основе хэша запроса (менее точен)
- на основе служебных хэдеров

> [!warning] Такие подходы резко снижают эффективность балансировки
> Лучше делегировать хранение сесссий на внешний кэш (redis)
### Как работают балансировщики?
![[Pasted image 20250930083522.png]]
для общего развития. всё!
### Ещё раз по trade-off-ам

| Аспект                | L4                                          | L7                                                                       |
| --------------------- | ------------------------------------------- | ------------------------------------------------------------------------ |
| Производительность    | Высокая производительность, низкая задержка | Выше задержка за счёт оверхэда                                           |
| Функции               | Простое разделение трафика                  | Роутинг на основе контента пакета, расшифровка пакета HTTPS, кэширование |
| Сложность             | Просто настраивается                        | Сложнее со всеми фичами                                                  |
| Использовать в случае | DNS, стриминг контента, игры, БД            | Веб-сервисы, микросервисная архитектура                                  |
| Стоимость             | Низкая                                      | Высокая                                                                  |
# Кэширование

Если балансировка нагрузки распределяет нагрузку по серверам, то кэширование ускоряет конкретные ноды или реже всю систему
### Принцип локальности
#### Временная локальность

Если данные запросили недавно, то большая вероятность того, что их запросят снова
#### Местная локальность

Данные в непосредственной близости от запрошенных данных с большей вероятностью подгрузят сразу после них. например, с подгрузкой странички товара в онлайн-магазине подгрузят картинки товара

> [!info] Вывод
> Кэшировать надо часто и много разных данных 
### Иерархия кэширования 

Чем глубже, тем дальше от клиента и медленнее кэш

1. Клинетский кэш — никак не зависит от нас, но ускоряет загрузку при повторных запросах в краткосрочной перспективе
2. CDN (edge cache) — кэширует самые частые запросы в гео зоне
3. Кэш балансировщика/сервера — серверное решение кэширует самые частые запросы, которые через него проходят
4. Кэш приложения — redis, memcached

а есть ещё кэш БД — автоматические кэши дорогих запросов
## Стратегии кэширования
### Ленивая загрузка (lazy-loading)

Грузить данные, только если их нет в кэше. Иначе дать кэш. Первая загрузка всегда медленная, но последующие быстрее. Прост в реализации, но чувствителен к изменчивости кэша
### Сквозная запись (wtire-through)

Сильно замедляет запись, записывая данные и в кэш, и в БД. Зато наряду со скоростью увеличивает консистентность данных
### Отложенная запись (write-back)

Записать сначала в кэш, а потом, когда кэш изменится, в БД. быстрее всех, но наименее надёжен, т.к. данные можно потерять до записи в БД из-за сбоев системы и в частности сбоя кэша
### Подгрузить заранее (refresh ahead)

Поставить *фактор записи заранее* (обычно 50% от ttl кэша), по истечению которого при запросе популярных данных, сначала дать данные из кэша, а потом подгрузить свежий кэш из БД. Более равномерная нагрузка на БД, но сложнее всех настроить под свой случай
![[Pasted image 20250930085434.png]]
## Удаление кэша

Когда кэш заканчивается, то нужно решить, что удалять, т.к. место в оперативе не бесконечное

Удаляется по паттернам:
- Least-recently used — стандарт. удалить наиболее старый кэш
- Least-frequently used — удалить наименее популярный
- FIFO — очередь


![[Pasted image 20250930090149.png]]

![[Pasted image 20250930090911.png]]
![[Pasted image 20250930091921.png]]

