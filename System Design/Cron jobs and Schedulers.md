# Что такое планировщик?
## В начале был UNIX

Изначально для планирования задач в UNIX было две утилиты:
- `at` — простой планировщик, откладывающий единоразовую задачу на потом
- `cron` — демон, следящий за расписанием в cron tab'ах и выполняющий задачу по установленному времени

`cron` вполне мог закрывать рутинные задачи по обработке логов и бэкапа базы данных, но был рассчитан на непрерывно работающую систему

А как мы знаем

> Мы не можем обеспечить 100% доступности системы. Никогда.

Поэтому был создан `anacron`, который запускал задачи после относительной задержки после загрузки системы. Таким образом, система не могла пропустить запланированную задачу из-за сбоя

Тем не менее, даже у `anacron` были недостатки:
- Single point of failure 
- Не масштабируется
- Сложно переносить между серверами — т.к. основу составляют скрипты
- Нет мониторинга между системами
# Современные планировщики
## Декларативная парадигма

Новые планировщики, такие как Apache AirFlow, работают на декларативной парадигме — вместо описания механизма работы каждой задачи и её времени выполнения, описать условия, зависимости, и принципы их выполнения в зависимости от состояния системы. Вместо "Как?" написать "Зачем?"

Это легко достигается за счёт описания запланированных задач в **направленных ацикличных графах**
# Планировщики подкапотно
## Модель данных хронов
### DAG — Directed Acyclic Graph

**Направленный ацикличный граф** представляет собой модель из узлов (задач) и рёбер, которые их соединяют (и указывают на зависимости задач), а также сохраняет ацикличность выполнения и указывает направление работы системы
## Структура планировщика

Планировщик задач в декларативной парадигме не единственный актор. Вся система планирования состоит из следующихт компонентов:

- Планировщик — мозг системы, постоянно запрашивающий существующие задачи у базы данных, их состояние и распределяющий неработающие задачи к выполнению в очереди
- База данных — хранить метаданные важно, даже если это просто 4 таблички задач и их статусов. Поэтому для сохранения статусов задач планировщика мы используем постоянное хранилище данных
- Очередь — буфер для запланированных задач
- Пул исполнителей — кластеры, поды, контейнеры, которые выполняют задачи из очереди
### Планировщик

1. Опрашивает какие задачи есть
2. Проверяет время для каждой задачи
3. Проверка задач, готовых к (повторному) выполнению
4. Постановка задач в очередь \[для воркеров]
	- Отслеживание выполнения поставленных в очередь задач через Heartbeat — если воркер умер, запланировать задачу для повторного выполнения

При этом зачастую для отказоустойчивости планировщиков также запускают несколько — если умрёт один, другой унаследует все его задачи, уменьшив пропускную способность, но сохранив доступность системы
#### Push vs Pull

Push прямо отдаёт задачу исполнителю — сложнее, но работает с минимальной задержкой

Pull отдаёт задачу в очередь на откуп исполнителей — более популярная (AirFlow и т.д.) — так как проще в реализации и масштабировании, а также отказоустойчивая
### Workflow as Code

Такие задачи просто опредеелять в коде, часто на скриптовом языке типа Python

```
task_A >> task_B
task_B.set_upstream(task_C)
```

Такой код может динамически генерироваться компонентами системы, типа базы данных или кэша

При этом на базе данных планировщика хранятся следующие таблицы:
- dag — таблица задач
- dag_run — статус состяний задач
- task_instance — конкретный статус задачи
- serialized_dag — кэш для подгрузки задач из базы данных на JSON вместо повторного чтения из файла
# Свойства планировщиков
## Отказоустойчивость
#### Идемпотентность

Задачи должны иметь такой же результат при многоразовом исполнении, как и при единоразвом исполнении. `INSERT` не идемпотентен, а `INSERT ... ON CONFLICT DO NOTHING` уже идемпотентен
#### Стратегии повтора

Не сдаваться сразу, а пробовать снова после интервала (часто увеличивающийся по экспоненте)
#### Jitter

Случайное значение, на которое умножается каждый инервал, чтобы множество перевыполняющихся задач не перегрузили систему
## Высокая доступность
#### Активный-пассивный (на основе кворума)

Один планировщик выполняет прямые обязанности, остальные подхватывают, если лидер умрёт — сложнее на уровне планировщика
#### Активный-пассивный (на основе блокировок БД)

Задействуют естественную блокировку таблиц на `INSERT`/`UPDATE` на уровне баз данных инфраструктуры. Больше нагрузка на БД
#### Активный-активный

Несколько планировщиков работают параллельно, активно блокируя запланированные задачи во внутренней базе данных на время их работы. Более масштабируемая, но более сложная и требовательная к новым технологиям система
