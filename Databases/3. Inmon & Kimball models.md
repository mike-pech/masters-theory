# Нормальные формы реляционной модели

Обычная нормализация баз данных заключается в уменьшении избыточности (redundancy) — элементы отношений дробятся на большее количество отношений для централизованных (желательно атомарных) обновлений данных. 

К примеру, в первой нормальной форме надо разделить данные по их домену (типу) — вместо хранения всех данных об объекте в одном JSON-е, мы разбиваем его на отношение объектов и характеристик и связываем связующей таблицей **где каждая связь объект-характеристика имеет значение**

Проблемы:
- JOIN — сильно снижает скорость добавления и получения информации. При третьей нормальной форме уже страдает выборка данных при её декомпозиции (поэтому для оптимизации под чтение можно денормализоваться до второй нормальной форме)
- Усложнение логики — при декомпозиции также усложняется сама логика выборки и обновления данных, так как наши сущности разбиваются на разные таблицы, и, чтобы обновить одну сущность, становится недостаточно обновить одну таблицу. Становится необходимым обновить две, три или более таблиц, на которые декомпозированы характеристики объекта
- Сложнее получать аналитику по разным доменам сущностей — например для аналитики по разным отделам нужно делать запросы к сущностям разных отделов, даже если по факту эти отделы связаны в реальной жизни 

![[Pasted image 20251013083440.png]]
# Подходы Инмона
### Субъектно-ориентированная модель

Объект один — характеристики разные в зависимости от точки зрения или отдела. Маркер для бухгалтерии — цена закупки; для маркетинга — цвет и время использования и т.д.

![[Pasted image 20251013083631.png]]
### Интегрированные данные

Агрегирование данных с разных отделов в одном домене
### Time-variant

Агрегирование данных в зависимости от времени
### Non-volatile

Данные не меняются задним числом
# Enterprise Data Warehouse — модель Инмона

В OlTP (Online Transaction Processing) хорошей идеей будет агрерировать все данные в одну централизованную сложную систему под названием Data warehouse. Такая система помогает с более простым доступом к аналитике 
### Слои
- Staging — подготовка данных, приведение к стандарту при помощи ETL (Extract, Transform, Load)
- View, Data Mart — витрина данных для аналитиков
## Slowly Changing Dimensions

Уровни управления историчностью данных 
### 1 уровень — Нет хранения

Историчности нет — изменение есть перезапись
### 2 уровень — Версионирование

Изменения записываются рядом со старыми данными
### 3 уровень — + старое значение

Актуальное хранение + OLD значение — только 2 значения, но проще хранить и получать данные
### 4 уровень — хранение отдельной истории

1 актуальная таблица + 1 историческая таблица
# Подход Кимбалла

Не нужно больших хранилищ — нужно хранить данные в «снежинках» фактов с описаниями в виде ответвлений

Пример: факт продажи — ID покупателя, цена и время продажи, ID товара, выбранный вариант доставки

![[Pasted image 20251013090544.png]]

Для сохранения разных типов фактов при разных сценариях факты делят на разные типы:
### Транзакция

### Snapshot

Слепок данных из определённого времени. Хороши для регулярных проверок и сохранения статуса данных
### Event

Фиксируем конкретное событие системы без деталей
### Документация