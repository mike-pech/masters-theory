# База

Хэш-таблица — это контейнер для ключей на основе хэш-функции — функции, преобразующей значение (часто число) в индекс в "массиве", который занимает хэш-таблица

Используется как динамичесикй легковесный контейнер данных с очень быстрым поиском по ключам

Как получить нужный размер хэш-таблицы?
	— Выделяется массив (обычно) на 1,3×n элементов, где n — ожидаемое количество ключей
# Хэш-функция

_Идеальная_ хэш-функция:
- Не создаёт коллизий (нереалистично)
- Детерминированная (один инпут всегда выдаёт один аутпут)
- Быстрая
- Распределяет значения по размеру всей таблицы равномерно — без _кластеризации_ ключей в каком-либо участке подлежащего массива
- Эффект лавины — малейшее изменение заметно меняет хэш
- **Полностью** зависит от ключа
#### Универсальное семейство хэш-функций

Это способ случайного выбора хэш-функции в зависимости от параметров, например

$$|(ax + b) \% n|$$
Где
>	a, b  — параметры с D \[1...n] и \[0...n] соотвественно
>	x — вставляемое значение
>	n — размер подлежащего массива

Параметры задаются изначально, и при замене обязательно перехэшировать существующие значения
# Коллизии

Допустим, наша хэш-функция простая — остаток отделения на 11

Тогда:
> 	15 % 11 = 4
> 	26 % 11 = 4
> 	
> 	Одна ячейка? Это коллизия!

К сожалению даже с большим массивом и хорошей хэш-функцией, мы всё равно будем ловить коллизии. С этим надо как-то жить

Поэтому мы вводим значение не просто по индексу в таблице, но и по паре ключ-значение — приблизительно мы ищем по индексу в массиве, точно по ключу в паре в ячейке таблицы
## Закрытая адресация (цепочки)

Привязать к элементу по ключу связный список и при коллизии добавить новое значение в начало этого связного списка

Тогда ячейка (а точнее узел) состоит их 3 условных частей — `[ Ключ ; Значение ; указатель на сл. узел ]`

Порядок не важен, так как элементы всё рано в коллизии

![[Pasted image 20251113194607.png]]
Сложность добавления O(1)¹

При поиске элемента просто _проходим_ по вариантам — равен ли наш ключ значению ключа в узле списка. При нахождении ключа просто возвращаем соответствующее значение из структуры узла

По асимптотике коллизия всё равно маловероятна, поэтому поиск элемента по списку — амортизированная O(1)

> ¹ При большой кластеризации меняем хэш-функцию (и перехэшируем таблицу!). Поэтому эта 1 — амортизированная

Популярен в большинстве реализаций хэш-таблиц
## Открытая адресация

В случае коллизии находим для нового элемента первую свободную ячейку справа (_пробирование_) или, если таблица переполнилась, перехэшируем таблицу

Последовательный шаг — $h(x) + i × 1$

Проблема с этим подходом — кратное увеличение кластера значений коллирующих ключей — с каждой коллизией с шагом в 1 у нас увеличивается шанс коллизии

Решение? 
### Другой шаг

Задать другой шаг:
- Линейный (не 1) — $h(x) + i×c$
- Квадратичный — $h(x) + i^c$ или $h(x) + i^{c1}   \%   i^{c2}$

![[Pasted image 20251113200403.png]]
Разница шагов — квадратичный справа и линейный слева
### Шаг через хэш-функцию

Вероятность одинакового шага уменьшается ещё сильнее, если выяснять шаг путём хэш-функции. Тогда вероятность увеличения кластера будет равна вероятности попадания в ту же ячейку И вероятности получения того же шага в хэш-функции (что вместе маловероятно)

Двойное хэширование — $h(x) + i × g(x)$, где $g(x)$ другая хэш-функция
### Что делать с удалением?

Если удалить ячейку, то мы можем сломать поиск, если в ячейке на следующем шаге всё ещё есть значение — тогда при поиске мы остановимся на "дырке" и никогда не дойдём до следующего значения

Поэтому вместо удаления мы помечаем элемент ячейке как удалённый — вследствие чего мы можем потом его перезаписать — а поиск не затронет
## Метод кукушки

Основная идея хеширования кукушки — использование двух хеш-функций вместо одной ($h1(x)$ и $h2(x)$). Также есть вариант алгоритма, в котором используются две хеш-таблицы, и первая хеш-функция указывает на ячейку из первой таблицы, а вторая — из второй

![[Pasted image 20251114084022.png]]
### Добавление

1. Если одна из ячеек с индексами $h1(x)$ или $h2(x)$ свободна, кладем в нее элемент
	1. Иначе произвольно выбираем одну из этих ячеек, запоминаем элемент, который там находится, помещаем туда новый
	2. Смотрим в ячейку, на которую указывает другая хеш-функция от элемента, который запомнили, если она свободна, помещаем его в нее
		1. Иначе запоминаем элемент из этой ячейки, кладем туда старый. Проверяем, не зациклились ли мы
		2. Если не зациклились, то продолжаем данную процедуру поиска свободного места пока не найдем свободное место или зациклимся
			1. Иначе выбираем 2 новые хеш-функции и перехешируем все добавленные элементы
			2. Также после добавления нужно увеличить размер таблицы в случае если она заполнена
### Удаление

Ищем элемент в ячейках по хэш-функциям $h1(x)$ и $h2(x)$ и, если находим, помечаем его ячейку как свободную (т.к. нам снова важно не сломать поиск)
### Поиск элемента

1. Смотрим ячейки с индексами $h1(x)$ и $h2(x)$ 
	1. Если в одной из них есть искомый элемент, возвращаем true
		1. Иначе возвращаем false

Удаление и проверка происходят за O(1) (что является основной особенностью данного типа хеширования), добавление — за **амортизированную** O(1). Первые два утверждения очевидны: требуется проверить всего лишь 2 ячейки таблицы

Однако, с заполнением таблицы есть всё большая вероятность зацикливания, что приводит к замене хэш-функций и перехэшированию, а соответственно к более медленному времени добавления
