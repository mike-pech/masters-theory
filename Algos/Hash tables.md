# База

Хэш-таблица — это контейнер для ключей на основе хэш-функции — функции, преобразующей значение (часто число) в индекс в "массиве", который занимает хэш-таблица

Используется как динамичесикй легковесный контейнер данных с очень быстрым поиском по ключам

Как получить нужный размер хэш-таблицы?
	— Выделяется массив (обычно) на 1,3×n элементов, где n — ожидаемое количество ключей
# Хэш-функция

_Идеальная_ хэш-функция:
- Не создаёт коллизий (нереалистично)
- Детерминированная (один инпут всегда выдаёт один аутпут)
- Быстрая
- Распределяет значения по размеру всей таблицы равномерно — без _кластеризации_ ключей в каком-либо участке подлежащего массива
- Эффект лавины — малейшее изменение заметно меняет хэш
- **Полностью** зависит от ключа
#### Универсальное семейство хэш-функций

Это способ случайного выбора хэш-функции в зависимости от параметров, например

$$|(ax + b) \% n|$$
Где
>	a, b  — параметры с D \[1...n] и \[0...n] соотвественно
>	x — вставляемое значение
>	n — размер подлежащего массива

Параметры задаются изначально, и при замене обязательно перехэшировать существующие значения
# Коллизии

Допустим, наша хэш-функция простая — остаток отделения на 11

Тогда:
> 	15 % 11 = 4
> 	26 % 11 = 4
> 	
> 	Одна ячейка? Это коллизия!

К сожалению даже с большим массивом и хорошей хэш-функцией, мы всё равно будем ловить коллизии. С этим надо как-то жить

Поэтому мы вводим значение не просто по индексу в таблице, но и по паре ключ-значение — приблизительно мы ищем по индексу в массиве, точно по ключу в паре в ячейке таблицы
## Закрытая адресация (цепочки)

Привязать к элементу по ключу связный список и при коллизии добавить новое значение в начало этого связного списка

Тогда ячейка (а точнее узел) состоит их 3 условных частей — `[ Ключ ; Значение ; указатель на сл. узел ]`

Порядок не важен, так как элементы всё рано в коллизии

![[Pasted image 20251113194607.png]]
Сложность добавления O(1)¹

При поиске элемента просто _проходим_ по вариантам — равен ли наш ключ значению ключа в узле списка. При нахождении ключа просто возвращаем соответствующее значение из структуры узла

По асимптотике коллизия всё равно маловероятна, поэтому поиск элемента по списку — амортизированная O(1)

> ¹ При большой кластеризации меняем хэш-функцию (и перехэшируем таблицу!). Поэтому эта 1 — амортизированная

Популярен в большинстве реализаций хэш-таблиц
## Открытая адресация

В случае коллизии находим для нового элемента первую свободную ячейку справа (_пробирование_) или, если таблица переполнилась, перехэшируем таблицу

Последовательный шаг — $h(x) + i × 1$

Проблема с этим подходом — кратное увеличение кластера значений коллирующих ключей — с каждой коллизией с шагом в 1 у нас увеличивается шанс коллизии

Решение? 
### Другой шаг

Задать другой шаг:
- Линейный (не 1) — $h(x) + i×c$
- Квадратичный — $h(x) + i^c$ или $h(x) + i^{c1}   \%   i^{c2}$

![[Pasted image 20251113200403.png]]
Разница шагов — квадратичный справа и линейный слева
### Шаг через хэш-функцию

Вероятность одинакового шага уменьшается ещё сильнее, если выяснять шаг путём хэш-функции. Тогда вероятность увеличения кластера будет равна вероятности попадания в ту же ячейку И вероятности получения того же шага в хэш-функции (что вместе маловероятно)

Двойное хэширование — $h(x) + i × g(x)$, где $g(x)$ другая хэш-функция
### Что делать с удалением?

Если удалить ячейку, то мы можем сломать поиск, если в ячейке на следующем шаге всё ещё есть значение — тогда при поиске мы остановимся на "дырке" и никогда не дойдём до следующего значения

Поэтому вместо удаления мы помечаем элемент ячейке как удалённый — вследствие чего мы можем потом его перезаписать — а поиск не затронет
## Метод кукушки