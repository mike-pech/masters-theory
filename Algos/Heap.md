# Добавление

При добавлении элементов в кучу нужно отсортировать новый элемент, чтобы сохранить правильность кучи
## Добавление через SiftUp

При каждом добавлении просто просеиваем кучу сверху вниз. Сложность — O(n log n)

![[Pasted image 20251016190256.png]]

![[Pasted image 20251016190308.png]]

![[Pasted image 20251016190426.png]]
## Добавление через SiftDown

> Но при большом количестве элементов просеивать кучу сверху вниз на каждую вставку неэффективно. Что делать?

Просеивать вниз, но постепенно:
- Листья (в том числе новый лист со вставленным элементом) просеивать не надо, т.к. он и так является правильной кучей
- 1-й слой над листьями просеиваем вниз 
- 2-й слой делаем правильные кучи высотой 3, просеивая вниз — нижние элементы просеивать не надо — 1-й и 0-й слой всё равно правильные кучи
- И. т. д. — решение из разряда «Разделяй и властвуй»

![[Pasted image 20251016190914.png]]
#### Сложность SiftDown

- Половина элементов кучи — листья. Их всё равно просеивать не нужно — 0 действий — пропускаем сразу $n / 2$ действий 
- Вершины с высотой 1 — $n / 2 / 2 = n / 4$
- Между 1 слоем и вершиной постоянно берём половину сложности — сумма сложностей стремится к 1, но слагаемых не равное количество
- Тем не менее, сумма отдельных слагаемых небольшая и стремится к соответствующим дробям, поэтому этот фактор не настолько большой, поэтому имеем ряд:

$1/2 + 1/4 + 1/8 + 1/16 + ... + 1/n = O(1)$

![[Pasted image 20251016191929.png]]
- Вершины с двумя ветками — максимум 2 свапа

![[Pasted image 20251016191632.png]]
# Слияние

Даны две кучи-массива — нужно слить их воедино и поучить одну большую кучу. Куча размером n и куча размером m
## Наивный подход

Слить два массива и просеять через SiftDown. Сложность O(n+m)
# Удаление
## Удаление максимального элемента

Свапнуть первый и последний элемент и сдвинуть указатель кучи. Таким образом в конце мы получим массив, отсортированный по возрастанию

![[Pasted image 20251016193721.png]]

Это называется Heap Sort! Сортировка пирамидкой — сложность O(n log n) — строим кучу O(n), выбираем максимальный O(1), просеиваем вниз O(log n) n раз
Память не требуется — O(1)