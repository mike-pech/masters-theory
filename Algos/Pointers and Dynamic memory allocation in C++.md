> При программировании в C++ каждый высокоуровневый нормис сталкивается с указателями. При такой встрече у него, как правило, срабатывает рефлекторное отвержение сего предмета, ведь по айтишным мемам он научен, что от указателей вешаются, поэтому их лучше обходить стороной и прогать на питоне

Но нам это не страшно, поэтому давайте разбираться.

В отступлении здесь — [[Asymptotic evaluation]] — было сказано про указатели вкратце — это просто переменные, которые напрямую хранят адреса других переменных в памяти. Ими можно удобно хранить в памяти элементы массива не копируя их, а храня на них прямую ссылку.
## Ссылка

`&` задаёт ссылку на переменную, т.е. присваивает переменной адрес в памяти другой переменной

```c++
i = &myvar; // Set i to myvar memory address
```

Переменная (`i`) получившая ссылку на адрес в памяти переменной `myvar` становится указателем на переменную `myvar`
## Указатели и дерефененс

Оператор `*` позволяет развернуть ссылку в переменной в значение адреса в памяти, на который она указывает. 

```c++
myvar = 25;
i = &myvar; // Set i to point to myvar (say 1776)
j = i;      // Set j to point to myvar by copying its address over from i
k = *i;     // Now set k to myvar's value — 25 — by dereferencing i
```

Указатель объявляется следующим образом:

```c++
тип * имя;
```

Тип может быть разным, но в общем и целом это всего лишь условность, обозначающая тип, **на который указывает указатель**, в то время как сами указатели скорее всего занимают одинаковое количество места в памяти. 
##### Пример

```c++
// my first pointer
#include <iostream>
using namespace std;

int main ()
{
  int firstvalue, secondvalue;
  int * mypointer;

  mypointer = &firstvalue;
  *mypointer = 10;
  mypointer = &secondvalue;
  *mypointer = 20;
  cout << "firstvalue is " << firstvalue << '\n';    // 10
  cout << "secondvalue is " << secondvalue << '\n';  // 20
  return 0;
}
```

> [!NOTE] `*` имеет значение
> Если переменная модифицируется без `*`, то меняется значение самого адреса — переменной указателя. Если перед названием указателя ставится `*`, то меняется значение переменной, на которую ссылается указатель
## Указатели и массивы

Массивы и указатели взаимосвязаны — так как они тоже указывают на какие-то значения в памяти, поэтому указатель можно неявно преобразовать в массив своего типа

Имея указатель на массив и используя квадратные скобки можно задать оффсет — дерефенеснуть указатель, предварительно добавив к нему значение в скобках, чтобы получить адрес в памяти больше или меньше данного. Соответственно указатель `i[n]`  будет указывать на значение на n адресов до или после оригинального значения указателя (привет `null pointer exception`)
## Арифметика указателей
> Ну погнали!

Указатели — это не просто ссылки, а всё такие же значения как и другие переменные, поэтому их можно менять. Но всё не так просто....

![[Pasted image 20250918211945.png]]

Инкрементация и декрементация указателей происходит на то количество ячеек, сколько байт занимает тип указателя. Интуитивно это объясняется так, что если следующие n байт заняты значением типа указателя, то логичнее будет перешагнуть эти ячейки в целом к следующему значению (не обязательно того же типа)
## Работа с динамической памятью

Обычно память выделяется на запуске программы при выделении памяти под переменные в соответствии с их типом и остаётся таким до конца программы. Но в C++ в угоду производительности можно самому работать с памятью.

По форме

```C++
переменная_указателя = new тип 
переменная_указателя = new тип [кол-во элементов] 
```

Можно задать место в памяти. При этом `new` вернёт указатель на начало выделенной памяти, поэтому можно сразу определить переменную указателя.

Выделенное пространство можно освободить при помощи `delete`. В случае, если `delete` передан пустой указатель ничего не произойдет (и хорошо) ``

```C++
delete pointer;
delete[] pointer;
```