## Бинарный поиск

##### Задача: найти элемент x в отсортированном массиве
###### Решение

1. Возьмём элемент в середине массива (а)
2. Сравним его с x
3. Если x:
	- Больше, значит на интересует то, что справа от a
		- Меньше, значит на интересует то, что слева от a
	- Равен a, значит мы нашли x
4. Повторять до того, как найдём x или искать будет негде — значит, x в массиве нет

```c++
int find(arr, n, x) {
	int left = 0;
	int right = 0;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (arr[mid] == x) {
			return mid;
		} 
		if (x > arr[mid]) {
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}
	return -1;
}
```
#### Бинарный поиск по ответу
- Найти максимальное (или минимальное) значение параметра x, при котором выполняется заданное условие 
- Известен примерный диапазон ответа
- При значениях параметра x до какого-то момента условие выполняется; после какого-то момента — перестаёт выполнятся; или наоборот — нужно найти границы
#### Как работает?
1. Рассматриваем потенциальный ответ (берём середину из диапазона возможных ответов)
2. Проверяем заданное условие с выбранным значением параметра x
3. Если:
	- Условие выполнилось -> запомнили, но пошли проверять значения больше (если ищем максимальное)
	- Условие не выполнилось -> проверяем значения меньше
- Поиск максимального x при котором условие выполняется — правосторонний бин поиск
- Поиск минимального x при котором условие выполняется — левосторонний бин поиск
#### Сложность
- Время — $o(log n ⋅ o(f(x)))$, где $o(f(x))$ — оценка времени работы функции проверки условия, а n — количество перебираемых ответов
- Память — $o(o(g(x)))$, где $o(g(x))$ — оценка памяти, которую требует функция проверки условия

![[Pasted image 20250925203100.png]]

```go 
func check(x, k int, chairs []int) bool {
	var k_count = 1
	var last_k = chairs[0]
	for _, c := range chairs {
		if c-last_k >= x {
			k_count++
			last_k = c
		}
	}
	return k_count >= k
}

func search(k int, chairs []int) int {
	n := len(chairs)
	
	var l = 0
	var r = chairs[n-1] - chairs[0]
	for r-l > 1 {
		m := (l + r) / 2
		if check(m, k, chairs) {
			l = m
		} else {
			r = m
		}
	}
	
	return l
}
```

![[Pasted image 20251002190439.png]]

![[Pasted image 20251002190539.png]]
# Тернарный поиск

Нужен для поиска максимума и минимума унимодальной функции. делит на три части и отбрасывает одну

## Алгоритм

1. Поделим отрезок на 3 части двумя точками m1 и m2
2. Сравним между собой значения функции от m1 и m2
3. Сделаем вывод, где не может находится экстремум и отбросим эту часть 
4. Продолжать до тех пор, пока не останется достаточно маленький отрезок для необходимой точности — далее выбираем точку

![[Pasted image 20251002191030.png]]

![[Pasted image 20251002191255.png]]
В этом случае отбрасываем части 1 и 3
### А как поделить?

Можно поделить поровну

А можно поделить в пропорциях золотого сечения — 1.618 — тогда будет лучше сходимость

![[Pasted image 20251002191627.png]]

![[Pasted image 20251002191807.png]]

```go 
func realBinSearch(k int, left, right, eps float64, arr []int) (int, int) {
	var a, b int
	for right-left > eps {
		mid := (left + right) * 0.5
		c := 0
		numMem, denMem := 0, 1
		
		j := 1
		for i := 0; i < len(arr)-1; i++ {
			// Находим индекс первого знаменателя, который делает дробь меньше mid
			for j < len(arr) && float64(arr[i]) > mid*float64(arr[j]) {
				j++
			}
			if j < len(arr) { // Все дроби после j гарантированно меньше mid
				c += len(arr) - j
				// Преобразованное неравенство дробей
				if arr[i]*denMem > numMem*arr[j] {
					numMem, denMem = arr[i], arr[j]
				}
			}
		}
		
		if c > k {
			right = mid
		} else if c < k {
			left = mid
		} else {
			a, b = numMem, denMem
			break
		}
	}
	return a, b
}
```