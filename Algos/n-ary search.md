## Бинарный поиск

##### Задача: найти элемент x в отсортированном массиве
###### Решение

1. Возьмём элемент в середине массива (а)
2. Сравним его с x
3. Если x:
	- Больше, значит на интересует то, что справа от a
	- Меньше, значит на интересует то, что слева от a
	- Равен a, значит мы нашли x
4. Повторять до того, как найдём x или искать будет негде — значит, x в массиве нет

```c++
int find(arr, n, x) {
	int left = 0;
	int right = 0;
	while (left <= right) {
		int mid = left - (right - left) / 2;
		if (arr[mid] == x) {
			return mid;
		} 
		if (x > arr[mid]) {
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}
	return -1;
}
```
#### Бинарный поиск по ответу
- Найти максимальное (или минимальное) значение параметра x, при котором выполняется заданное условие 
- Известен примерный диапазон ответа
- При значениях параметра x до какого-то момента условие выполняется; после какого-то момента — перестаёт выполнятся; или наоборот — нужно найти границы
#### Как работает?
1. Рассматриваем потенциальный ответ (берём середину из диапазона возможных ответов)
2. Проверяем заданное условие с выбранным значением параметра x
3. Если:
	- Условие выполнилось -> запомнили, но пошли проверять значения больше (если ищем максимальное)
	- Условие не выполнилось -> проверяем значения меньше
- Поиск максимального x при котором условие выполняется — правосторонний бин поиск
- Поиск минимального x при котором условие выполняется — левосторонний бин поиск
#### Сложность
- Время — $o(log n ⋅ o(f(x)))$, где $o(f(x))$ — оценка времени работы функции проверки условия, а n — количество перебираемых ответов
- Память — $o(o(g(x)))$, где $o(g(x))$ — оценка памяти, которую требует функция проверки условия

![[Pasted image 20250925203100.png]]

