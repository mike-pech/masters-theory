## Бинарный поиск

##### Задача: найти элемент x в отсортированном массиве
###### Решение

1. Возьмём элемент в середине массива (а)
2. Сравним его с x
3. Если x:
	- Больше, значит на интересует то, что справа от a
	- Меньше, значит на интересует то, что слева от a
	- Равен a, значит мы нашли x
4. Повторять до того, как найдём x или искать будет негде — значит, x в массиве нет

```c++
int find(arr, n, x) {
	int left = 0;
	int right = 0;
	while (left <= right) {
		int mid = left - (right - left) / 2;
		if (arr[mid] == x) {
			return mid;
		} 
		if (x > arr[mid]) {
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}
	return -1;
}
```
#### Бинарный поиск по ответу
- Найти максимальное (или минимальное) значение параметра x, при котором выполняется заданное условие 
- Известен примерный диапазон ответа
- При значениях параметра x до какого-то момента условие выполняется; после какого-то момента — перестаёт выполнятся; или наоборот — нужно найти границы
#### Как работает?
1. Рассматриваем потенциальный ответ (берём середину из диапазона возможных ответов)
2. Проверяем заданное условие с выбранным значением параметра x
3. Если:
	- Условие выполнилось -> запомнили, но пошли проверять значения больше (если ищем максимальное)
	- Условие не выполнилось -> проверяем значения меньше
- Поиск максимального x при котором условие выполняется — правосторонний бин поиск
- Поиск минимального x при котором условие выполняется — левосторонний бин поиск
#### Сложность
- Время — $o(log n ⋅ o(f(x)))$, где $o(f(x))$ — оценка времени работы функции проверки условия, а n — количество перебираемых ответов
- Память — $o(o(g(x)))$, где $o(g(x))$ — оценка памяти, которую требует функция проверки условия

![[Pasted image 20250925203100.png]]

![[Pasted image 20251002190439.png]]

![[Pasted image 20251002190539.png]]
# Тернарный поиск

Нужен для поиска максимума и минимума унимодальной функции. делит на три части и отбрасывает одну

## Алгоритм

1. Поделим отрезок на 3 части двумя точками m1 и m2
2. Сравним между собой значения функции от m1 и m2
3. Сделаем вывод, где не может находится экстремум и отбросим эту часть 
4. Продолжать до тех пор, пока не останется достаточно маленький отрезок для необходимой точности — далее выбираем точку

![[Pasted image 20251002191030.png]]

![[Pasted image 20251002191255.png]]
В этом случае отбрасываем части 1 и 3
### А как поделить?

Можно поделить поровну

А можно поделить в пропорциях золотого сечения — 1.618 — тогда будет лучше сходимость

![[Pasted image 20251002191627.png]]

![[Pasted image 20251002191807.png]]

```text
function feasible(M, L, C, Y):
    K = (Y - C - L) / 2
    Low = max(-M, -M - L, C + K - M, K - M)
    High = min(M, M - L, C + K + M, K + M)
    return (Low <= High)

function find_minimal_M(L, C, Y):
    low = 0.0
    high = 3.0
    while high - low > 1e-8:
        mid = (low + high) / 2
        if feasible(mid, L, C, Y):
            high = mid
        else:
            low = mid
    return (low + high) / 2
```