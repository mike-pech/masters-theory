Рекурсивные алгоритмы — это алгоритмы, которые вызывают сами себя. У них обязательно должен быть вызов самой себя, а также условие выхода — иначе цикл будет бесконечным

У рекурсивного алгоритма есть «дерево рекурсии» — последовательность рекурсивных вызовов, которое сначала идёт вглубь до условия выхода, а потом возвращается наверх к исходному условию

![[Pasted image 20250918194338.png]]
## Оценка памяти

Оценивая рекурсивные алгоритмы по памяти важно помнить, что мы храним рекурсивные вызовы — нужно помнить, куда возвращаться после выхода из функции. 
## Оценка времени

В асимптотической оценке времени рекурсивных функций мы должны учитывать рекурсивные вызовы как действия. Например, алгоритм выше займёт n времени.

![[Pasted image 20250918195510.png]]

В таком алгоритме у нас по два рекурсивных вызова функции — получается бинарное дерево вызовов.

Тогда в памяти нам нужно хранить высоту дерева, а времени такой алгоритм займёт по количеству вызовов (узлов в дереве).

![[Pasted image 20250918195854.png]]

![[Pasted image 20250918200617.png]]

![[Pasted image 20250925191242.png]]

![[Pasted image 20250925191401.png]]

![[Pasted image 20250925191613.png]]
Память:
- Одна целая единица + много половинок, которые складываются в ещё одну единицу

![[Pasted image 20250925192152.png]]
Время:
- Глубина дерева — log n
- n раз прошлись по массивам — аналогично памяти — k раз по n/k = n
## Мастер теорема

Теорема, используемая для оценки временной сложности рекурсивных алгоритмов. 

Пусть имеется рекуррентное соотношение:
$$
\begin{equation}
	T(n)=

		\begin{cases}
			& a T(n/b)+O(n^c),
			& n>1\\
			& O(1),
			& n=1	
		\end{cases}
\end{equation}
$$
где 
$$
a ∈N, b ∈R, b>1, c ∈R+
$$
задача размера n делится на a задач в b раз меньшего размера с коллапсом за $O (n^c)$

![[Pasted image 20250926170954.png]]
Тогда в таком дереве рекурсии будет $log_b n$ уровней, а на k-том уровне будет $a^k$ листьев

Тогда асимптотическое решение имеет вид:

1. Если $c>log_b a$, то $T(n)=O(n^c)$
2. Если $c=log_b a$, то $T(n)=O(n^c log n)$
3. Если $c<log_b a$, то $T(n)=O(n^{log_b a})$

[Доказательство](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%81%D1%82%D0%B5%D1%80-%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0#.D0.A4.D0.BE.D1.80.D0.BC.D1.83.D0.BB.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0_.D0.B8_.D0.B4.D0.BE.D0.BA.D0.B0.D0.B7.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D1.82.D0.B2.D0.BE_.D0.BC.D0.B0.D1.81.D1.82.D0.B5.D1.80-.D1.82.D0.B5.D0.BE.D1.80.D0.B5.D0.BC.D1.8B)



![[Pasted image 20250925192650.png]]
![[Pasted image 20250925193152.png]]
![[Pasted image 20250925193533.png]]
