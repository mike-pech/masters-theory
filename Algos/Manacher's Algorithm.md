Алгоритм Манакера позволяет эффективно посчитать количество палиндромов среди подстрок в исходной строке — временная сложность O(n) (Да, линейная!); сложность по памяти O(n) — для памяти нужен массив равный по длине исходной строке + спецсимволы (2n+2 ≈ n)

Мы определяем строгие границы (l, r) первого найденного справа палиндрома из подстроки, начиная с пустой строки (0, 1). Далее считаем палиндромы для i

Если i выходит за границы подстроки (l, r), то запускаем обычный счётчик

Если i <= r, то мы сверяемся с памятью уже посчитанных радиусов палиндромов. Ищем зеркальную позицию i в подстроке (l, r) — получаем `j = l + (r - i)`, чью позицию проверяем в памяти, и так как они зеркальны мы почти всегда можем гарантировать, что s\[i] == s\[j] 

![[Pasted image 20251016122857.png]]

Кроме случаев, когда i заходит за рамки внешнего палиндрома (l, r) — тогда j - p\[j] <= l или i + p\[i] >= r — поэтому ограничиваем длину палиндрома p\[i] до r - i и используем тривиальный алгоритм 

![[Pasted image 20251016122944.png]]

На каждой итерации не забываем обновить границы (l, r)

Секрет маленькой сложности алгоритма заключается в использовании памяти в массиве и то, что алгоритм никогда не идёт назад (кроме тривиального счётчика) и не проходится по алгоритму снова 

```go
func manacherOdd(s string) int {
	n := len(s)
	s = "^" + s + "$" // Спец символы для обработки краёв строки равно другим символам в строке
	p := make([]int, n+2)
	c := 0

	l, r := 0, 1
	for i := 1; i <= n; i++ {
		// Для  p[i] либо инициализируем, либо выбираем наименьший радиус палиндрома
		p[i] = max(0, min(r-i, p[l+(r-i)])) // ВНИМАНИЕ! Работает только на Go 1.21+
		for s[i-p[i]] == s[i+p[i]] { // Обычный счётчик (пока левый == правый)
			p[i]++
		}
		if i+p[i] > r { // Расширяем границы внешнего палиндрома если i вышел за них
			l = i - p[i]
			r = i + p[i]
		}
		c += p[i] / 2 // Добавляем значение для центра i к счётчику
		// Т.к. испльзуется целочисленное деление, значение p[i] = 1
		// (для спецсимволов) добавляется нулём
	}
	return c // Отрубаем спец символы в счётчике
}
```

Такой алгоритм работает для нечётных палиндромов вида `W = vav`, где `a` — произвольный символ и центр палиндрома. Однако этот же алгоритм можно использовать и для чётных палиндромов при помощи паддинга спец символами между букв — нечёт + нечёт = чёт 

```go 
func prepareManacher(s string) string {
	var t string
	for i := 0; i < len(s); i++ {
		t += "#" + string(s[i])
	}
	return t + "#" // строку вида "#a#b#o#b#a#" можно передать алгоритму
}
```

А вот на плюсах:

```c++
#include <iostream>
#include <vector>

using namespace std;

int manacher_odd(string s) {
	int n = s.size();
	s = "$" + s + "^";
	vector<int> p(n + 2);
	int c = 0;
	int l = 0, r = 1;
	for(int i = 1; i <= n; i++) {
		p[i] = min(r - i, p[l + (r - i)]);
		while(s[i - p[i]] == s[i + p[i]]) {
			p[i]++;
		}
		if(i + p[i] > r) {
			l = i - p[i], r = i + p[i];
		}
		c += p[i] / 2;
	}
	return c;
}

int manacher(string s) {
	string t;
	for(auto c: s) {
		t += string("#") + c;
	}
	int res;
	res = manacher_odd(t + "#");

    return res;
}

int main() {
	string s;
	cin >> s;

    int res;
    res = manacher(s);
	cout << res << endl;
	return 0;
}
```