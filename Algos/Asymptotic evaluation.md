Алгоритмы бывают разные — нужно уметь разбирать подходящие алгоритмы по контексту.

Алгоритмы нельзя рассматривать в конкретных случаях — рантайм зависит от входных данных, оптимизаций компилятора, работы процессора и т.д.

Мы оцениваем:
- T(n) — функция количества действий в зависимости от входных данных — 1 операция
- M(n) — функция объёма памяти в зависимости от входных данных — 1 переменная 

Единицы условные — операции и переменные разные, но имеют константное количество времени/памяти

![[Pasted image 20250917211046.png]]

Верхняя оценка O(g(n)) — с какого-то момента функция g(n), умноженная на константу c, будет больше, чем f(n) — маленькие n мы не рассматриваем — сортировка массива n = 5 всегда быстрая.

Для хорошей эвристической оценки важно подобрать самую наименьшую высшую оценку (здравый смысл)

![[Pasted image 20250917211746.png]]

То же самое, но наоборот — функция f(n) растёт не медленнее g(n).

![[Pasted image 20250917211839.png]]
Ограничивает f(n) внутри себя с определённого момента

![[Pasted image 20250917212214.png]]

![[Pasted image 20250917212840.png]]

![[Pasted image 20250917213038.png]]

![[Pasted image 20250917213923.png]]

![[Pasted image 20250917215149.png]]

![[Pasted image 20250917215452.png]]
## Случаи

Тем не менее, случаи бывают разные и при такой вариации имеет смысл рассмотреть разные случаи — лучший/худший и средний случаи

![[Pasted image 20250918191419.png]]

В среднем случае мы берём средние значения под предлогом, что и лучший, и худший случаи будут происходить половину времени
## Оценка памяти

Когда мы оцениваем память алгоритма, мы смотрим на память, которую использует алгоритм для своих целей, исключая входные данные (т.к. эти данные уже где-то хранятся на момент старта алгоритма). Например, при сортировке массива длиной n, алгоритм может выделить дополнительный массив той же длинны для своих целей —  O(n)
#### Указатели

В некоторых языках программирования (Go, C, C++ особенно) используются указатели — переменные, прямо указывающие на область в памяти. Имея указатель в C++, можно сделать динамический массив, по которому можно двигаться по индексу в указателе `a[i]` (указатель `a = new int*[n]`)

![[Pasted image 20250918192711.png]]
![[Pasted image 20250918193458.png]]

В 