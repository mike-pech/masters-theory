# Условие

> Дан массив из `n` элементов, для каждого элемента `i` которого нужно найти ближайшего соседа (справа/слева), который меньше `i`. Если такого элемента нет, вернуть `-1`

Пример:

```
Input:		1 6 2
Output:		-1 1 1
```
# Решение
## Наивный подход

Проход всего массива от i-го элемента до ближайшего наименьшего элемента (справа/слева)

Неоптимальное решение с асимптотикой O(n^2) по времени и O(1) по памяти
## Использование монотонно возрастающего стека

Монотонно возрастающий стек — это стек, в котором элементы хранятся в порядке неубывания. При добавлении в него элемента `i` меньшего текущему высшему элементу, элементы стека постепенно удаляются, пока не будет найден элемент меньший или равный `i`. Это даёт нам мощную структуру для обработки элементов массива

Мы проходим по массиву слева направо и для каждого элемента `i` сравниваем предыдущие для него элементы с ним. Элементы до него лежат в стеке с прошлых итераций. Так мы проходим, удаляя элементы из стека, пока:
- Мы не найдём элемент меньший `i` (т.е. мы постепенно удаляем элементы большие или равные `i` — они нам не нужны) 
- Либо пока стек не закончится, что будет означать, что такого числа нет

В последнем случае мы также исключаем лишние итерации, т.к. ближайший меньший элемент не может находится за элементом больше `i`

Далее решение для ближайшего меньшего элемента слева. Для подобной задачи справа, нам просто нужно идти справа налево (как в манге)

Асимптотика лучше — O(n) т.к. проходимся всего один раз по массиву. O(n) по памяти за хранение схожего по размеру стека

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

vector<int> prevSmaller(vector<int>& arr) {
	int n = arr.size();
	vector<int> result(n, -1);	// Если не повезёт, то вернём просто массив -1

	stack<int> st;

	for (int i = 0; i < n; i++) {
		
		// Удаляем элементы из стека, пока они больше или равны i-му
		// либо пока стек не закончится
		while (!st.empty() && st.top() >= arr[i]) {
			st.pop();
		}

		// Если стек не пуст, то сверху индекс ближайшего наименьшего числа
		if (!st.empty()) {
			result[i] = st.top();
		}

		// Отправляем элемент слева в стек для сравнения
		st.push(arr[i]);
	}
	return result;
}

int main() {
	vector<int> arr = {1, 5, 0, 3, 4, 5};
	vector<int> ans = prevSmaller(arr);

	for (int x : ans) cout << x << " ";
	return 0;
}
```
