# База

Бинарное дерево поиска представляет собой то же бинарное дерево, что и [[Heap]], но его узлы представляют собой абстрактные контейнеры для данных, вместо последовательных ячеек памяти

Поэтому у любого узла есть значение и ссылки на следующий и предыдущий элементы

![[Pasted image 20251016195637.png]]
## Высота

В бинарном дереве поиска обычно нет автоматической балансировки — поэтому его ветки могут быть несбалансированны — иметь разную высоту (h)

![[Pasted image 20251016200527.png]]

Высота определяется порядком вставки
# Операции
## Поиск

Просто идём по дереву и ищем через элементы, сравнивая их с искомыми. Если не нашли, ищем слева или справа аналогично бинарному поиску ([[n-ary search]]). Так идём до того, как найдём элемент или дойдём до Null 

При этом мы прошлись только по одной веточке дерева, но это и неважно — на каждом шаге мы выбираем самые оптимальные пути — поэтому если элемент не нашли, его точно нет

Сложность: 
- Время — O(log h), где h — высота дерева
- Память — O(1)
## Добавление

Идём по дереву вниз, пока не найдём узел, к которому можно будет присоединить новый лист — т.е. у него нет одного или двух детей

Проход по дереву аналогичен поиску — пока мы идём вниз, ищем наиболее подходящий путь к Null — больше/меньше добавляемого элемента

Сложность: 
- Время — O(log h), где h — высота дерева
- Память — O(1)
### Балансировка

Во избежание перегрузки какой-либо из ветвей дерева (что может значительно замедлить операции), дерево необходимо балансировать. Делается это во время операций добавления и удаления разными способами
#### Косое (Splay) дерево

Не имеет дополнительных атрибутов в узлах дерева. Операции вращения просто происходят во время **каждого обращения к дереву**

Сложность: 
- Время — O(log h) **Амортизированное**, т.к. часто вращение ни к чему не приводит, но иногда требует значительных преобразований 
- Память — O(1)
Обозначим вершину, которую хотим переместить в корень за _x_, её родителя — _p_, а родителя _p_ (если существует) — _g_.

**Zig:** выполняется, когда _p_ является корнем. Дерево поворачивается по ребру между _x_ и _p_. Существует лишь для разбора крайнего случая и выполняется только один раз в конце, когда изначальная глубина _x_ была нечётна.

![[Pasted image 20251025104816.png]]

**Zig-Zig:** выполняется, когда и _x_, и _p_ являются левыми (или правыми) сыновьями. Дерево поворачивается по ребру между _g_ и _p_, а потом — по ребру между _p_ и _x_.

![[Pasted image 20251025104826.png]]

**Zig-Zag:** выполняется, когда _x_ является правым сыном, а _p_ — левым (или наоборот). Дерево поворачивается по ребру между _p_ и _x_, а затем — по ребру между _x_ и _g_.

![[Pasted image 20251025104841.png]]
#### AVL-дерево

Дерево поддерживает баланс по правилу
> Высоты двух дочерних поддеревьев узла должны отличаться как максимум на 1 

Когда операция изменения нарушает правило, запускается балансировка дерева
##### Лево-лево

Когда левое дочернее поддерево перевешивает, сделать одно вращение вправо
##### Право-право

Когда правое дочернее поддерево перевешивает, сделать одно вращение влево
##### Лево-право

При внесении значения правым листом в левом поддереве, преревешивает левое поддерево, но простого разворота налево будет недостаточно

![[Pasted image 20251025124323.png]]
Поэтому меняем правый узел с левым в левом подереве, а потом делаем корень левого поддерева корнем дерева
##### Право-лево

Аналогично
![[Pasted image 20251025124436.png]]

Сложность: 
- Время — O(log n) на все операции
- Память — O(n)
#### Красно-чёрное дерево

Самобалансирующееся дерево, хранящее дополнительный бит цвета для каждого узла для обеспечения приблизительной сбалансированности

Во время изменения элементов дерева (вставки/удаления) структура дерева меняется либо по форме, либо по цвету. Таким образом поддерживается (относительно) одна и та же высота листьев — поддеревья чёрного цвета имеют одинаковую высоту, корень всегда чёрный

Например при вставке:
![[Pasted image 20251025113644.png]]

Или при удалении:
![[Pasted image 20251025114235.png]]

![[Pasted image 20251025114544.png]]

![[Pasted image 20251025114551.png]]

Сложность: 
- Время — O(log n) на все операции
- Память — O(n)
