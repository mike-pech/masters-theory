> Как структурировать коммуникацию в системе так, чтобы её загрузка была быстрой и доступной?
## Путь URL запроса
#### DNS — телефонная книга интернета

Domain Name System на системе пользователя или локальном сервере разрешает доменное имя в IP-адрес. 

Поиск:
1. Локальный кэш
2. Провайдер
3. TLD (Top-level domain) сервера
4. Авторитетный сервер

Структура основных типов DNS-записей:
- A Record — мап домена к IPv4 адресу
- AAAA Record — мап домена к IPv6 адресу
- CNAME — мап домена к другому домену
- MX Record — мап домена к почтовому серверу

GeoDNS — будет подсоединять пользователей к оптимальным по их географии серверам. Работает из коробки у облачных провайдеров.
#### CDN — Content Delivery Network

CDN хранит статические данные ресурса на более ближнем к юзеру сервере, которые загружаются незадолго после запроса для быстрой загрузки.

Hit or Miss — если на CDN есть копия контента сразу, то отдаём её сразу. Если нет, то загружаем из источника и кэшируем для будущих запросов
###### Типы CDN
- **Pull CDN** — автоматизированный сервер, который по необходимости (при запросе) подтягивает запрашиваемую информацию и кэширует её для будущих запросов. Прост и стандартен для многих CDN, но требует дополниетльного времени для подгрузки контента, которого на нём нет (что критично для больших файлов)
- **Push CDN** — подход, при котором ты сам заранее подгружаешь контент на CDN. Производительность предсказуема и не имеет задержки перед загрузкой больших файлов (если они уже на сервере), но требует ручной загрузки контента
#### Прокси

2 типа:
- Forward proxy — все виды проксирования на клиенте и служит для переадрессации запросов или обхода блокировок через внешнюю сеть. Может работать для фильтрации контента извне (чтобы ты в стиме на работе не сидел)
- Reverse proxy — действует от имени сервера и работает в его сети. Распределяет запросы клиентов по серверам сетевой инфраструктуры приложения
	- Также помогает расшифровать TLS-сертификат в запросе, чтобы внутренним сервисам передать уже расшифрованный запрос
	- Распоряжается кэшем внутри системы сервиса
	- Сжимает запросы и ответы для экономии трафика

## Протоколы TCP/UDP

**TCP** — протокол с гарантией соединения и доставки. Медленнее и сложнее, но гарантированно работает, так как подтверждает соединение через рукопожатие
###### TCP Three-Way Handshake
1. SYN (Synchronise) — запрос соединения от клиента с последовательным номером
2. SYN-ACK — сервер принимает номер и посылает свой последовательный номер
3. ACK — клиент принимает номер. Соединение установлено

> [!IMPORTANT] Только после этих шагов начинается передача данных в TCP
> И так для каждого соединения

**UDP** — отправил и забыл. Если что-то не дошло, дойдёт позже может быть. Идеален для видеозвонков или онлайн-игр
##### Шпаргалка TCP vs. UDP

| Характеристика       | TCP                                                | UDP                           |
| -------------------- | -------------------------------------------------- | ----------------------------- |
| Надёжность           | Высокая                                            | Низкая                        |
| Скорость             | Медленный                                          | Быстрый (минимальный оверхэд) |
| Порядочность пакетов | Гарантированна                                     | Нет                           |
| Случаи               | Передача файлов, веб-приложения, электронная почта | Стриминг, игры, DNS           |
#### Прикладные протоколы

###### REST API

**Re**presentational **S**tate **T**ransfer — набор архитектурных принципов для построения веб-приложений

Ключевые фичи:
- Ресурсы — всё что угодно — это ресурс, который имеет свой идентификатор
- Методы — служат для разделения типов запросов. Создать/получить/изменить/удалить — вещи стандартизированные.
- Без состояния — запросы имеют всё необходимое для обработки запроса
- Стандартизированные форматы — JSON/XML
###### gRPC

Фреймворк для удалённого вызова процедур на сервере. 

Ключевые фичи:
- Основан на HTTP/v2 и всегда сжимается для скорости/экономии
- Нужен внутренний Reverse прокси для распределения запросов
- Имеет встроенный функционал стриминга запросов
- Часто используется для внутренней коммуникации микросервисов

Имеет контракт, который обеспечивает Type Safety. Бинарный протокол в разы быстрее в сериализации и передачи, чем текстовый протокол
#### Real Time communication

> Что если нам надо отправить обновление клиенту?

###### Polling 

Клиент сам запрашивает информацию с малой периодичностью:
- Прост
- Неэффективен — большинство запросов возвращают пустой ответ и жрут ресурсы впустую
###### Long Polling 

Длинный запрос — клинет запрашивает данные, получает ответ, но сервер задерживает запрос на некоторое время до прихода нового сообщения; потом возвращает ответ с этим сообщением.
###### Web Socket 

Между клиентом и сервером устанавливается прямой пайп, при помощи которого клиент и сервер могут обмениваться данными на лету в течении того времени, пока есть сокет
###### События на стороне сервера (SSE)

События на сервере посылаются клиенту в одностороннем порядке при помощи HTTP в текстовом формате. Просто, основывается на обычном HTTP, легко подключается и переподключается, не мешает фаерволам, но поддерживает только одну сторону и подключается только на один домен — типа уведомлений calendar.google.com
##### Сравнение

| Паттерн      | Направленность    | Соединение            | Сложность    | Эффективность |
| ------------ | ----------------- | --------------------- | ------------ | ------------- |
| Polling      | Клиент ->  Сервер | Для каждого запроса   | Очень просто | Крайне низкая |
| Long-Polling | Клиент ->  Сервер | Для каждого сообщения | Средняя      | Низкая        |
| SSE          | Сервер -> Клиент  | Постоянное            | Просто       | Высокая       |
| WebSockets   | Двунаправленный   | Постоянное            | Сложно       | Очень высокая |
![[Pasted image 20250923085615.png]]
> [!INFO] Можно не ограничиваться одним стеком
> Системы могут совмещать различные технологии в зависимости от их целей
> 
> К примеру, можно использовать REST API в самом приложении, а для уведомлений использовать вебсокеты. 
> 
> Либо брать на вооружение более новые версии протоколов, например HTTP/3 (с поддержкой QUIC на основе UDP)
> 
> Нужно понимать уязвимости и ограничения различных видов технологий. При соединении вебсоектами нужно проверять каждый входящий пакет, а не только соединение при подключении. Также обычный REST API может быть неудобен при масштабировании системы  

![[Pasted image 20250923090113.png]]